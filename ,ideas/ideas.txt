# Scratchpad

```
# a = b + c
ld i, ${addr_b}
ld v0-v0, (i)
ld v1, v0
ld i, ${addr_c}
ld v0-v0, (i)
add v0,v1
ld i, ${addr_a}
ld (i),v0-v0
```







## Ideetjes

### Variabelen hebben een vaste locatie in geheugen

Voordeel: simpel
Nadeel: geen recursie

Load v1

```chip8
ld i, ${variable_x}
ld v0, (i)
ld v1, v0
```

Save v1

```chip8
ld i, ${variable_x}
ld v0, v1
ld (i), v0
```

### Variabelen zitten op een runtime stack

Voordeel: Flexibel, recursie mogelijk
Nadeel: Complex, traag in CHIP-8?

Byte at `stack` is an index that points to current scope in current function.
Variables in scope have a offset within their scope.

Load v1

```chip8
ld i, ${stack}
ld v0, (i)
add v0, ${var_x_offset}
add i, v0
ld v0, (i)
ld v1, v0
```

Save v1

```chip8
ld i, ${stack}
ld v0, (i)
add v0, ${var_x_offset}
add i, v0
ld (i), v1
```

### Function calls

In beide gevallen: registers veiligstellen tussen function calls is nog steeds
best een goed idee voor function calls in expressies:

things = 8 * stuff(5) + blerf();

We hebben dan tussenresultaten nodig, en die moeten danwel ook in tijdelijke
variabelen opgeslagen worden op de stack, danwel in registers die we
veiligstellen. Allebei lijkt me prima.

Registers opslaan hebben we al, maar slaat meer op dan nodig (trade off: RAM)
Tijdelijke variabelen zijn ws meer instructies? (trade off: speed)
